/**
 * Access Review Scheduler
 *
 * Handles automatic execution of scheduled reviews:
 * - Checks for due schedules and creates campaigns
 * - Auto-starts campaigns (collects permissions from SharePoint)
 * - Sends reminder notifications via email
 * - Auto-executes removals after review period ends
 * - Sends completion notifications
 *
 * This runs on Railway as an interval-based scheduler (vs Vercel cron for Next.js)
 */

import { db } from '../lib/db/prisma.js';
import { PermissionsClient, ResourcePermission } from '../lib/microsoft/permissions.js';
import { EmailClient } from '../lib/microsoft/email.js';
import type { Prisma } from '@prisma/client';

// Run interval in milliseconds (check every 5 minutes)
const CHECK_INTERVAL = 5 * 60 * 1000;

let isRunning = false;
let intervalId: NodeJS.Timeout | null = null;

// Base URL for dashboard links in emails
const APP_BASE_URL = process.env.APP_BASE_URL || 'https://auditsphere.nubewired.com';

// ============================================================================
// Email Templates
// ============================================================================

function generateCampaignStartedEmailHtml(
  campaignName: string,
  totalItems: number,
  campaignId: string
): string {
  const dashboardUrl = `${APP_BASE_URL}/access-review/campaigns/${campaignId}`;

  return `
<!DOCTYPE html>
<html>
<head><meta charset="utf-8"></head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f3f4f6; margin: 0; padding: 20px;">
  <div style="max-width: 600px; margin: 0 auto; background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <div style="background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%); padding: 30px; text-align: center;">
      <h1 style="color: white; margin: 0; font-size: 24px;">Access Review Started</h1>
    </div>
    <div style="padding: 30px;">
      <p style="color: #374151; font-size: 16px; margin: 0 0 20px;">
        A new access review campaign has been automatically created and started.
      </p>
      <div style="background: #f9fafb; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
        <p style="margin: 0 0 10px;"><strong>Campaign:</strong> ${campaignName}</p>
        <p style="margin: 0;"><strong>Items to Review:</strong> ${totalItems}</p>
      </div>
      <a href="${dashboardUrl}" style="display: inline-block; background: #3b82f6; color: white; text-decoration: none; padding: 12px 24px; border-radius: 6px; font-weight: 500;">
        Start Reviewing
      </a>
    </div>
    <div style="background: #f9fafb; padding: 15px; text-align: center; color: #6b7280; font-size: 12px;">
      Generated by AuditSphere
    </div>
  </div>
</body>
</html>`;
}

function generateReminderEmailHtml(
  campaignName: string,
  daysUntilDue: number,
  campaignId: string
): string {
  const dashboardUrl = `${APP_BASE_URL}/access-review/campaigns/${campaignId}`;
  const urgencyColor = daysUntilDue === 1 ? '#dc2626' : daysUntilDue <= 3 ? '#f59e0b' : '#3b82f6';

  return `
<!DOCTYPE html>
<html>
<head><meta charset="utf-8"></head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f3f4f6; margin: 0; padding: 20px;">
  <div style="max-width: 600px; margin: 0 auto; background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <div style="background: ${urgencyColor}; padding: 30px; text-align: center;">
      <h1 style="color: white; margin: 0; font-size: 24px;">⏰ Reminder: Review Due Soon</h1>
    </div>
    <div style="padding: 30px;">
      <div style="background: #fef3c7; border-left: 4px solid ${urgencyColor}; padding: 15px; border-radius: 0 8px 8px 0; margin-bottom: 20px;">
        <p style="margin: 0; color: #92400e; font-weight: 600;">
          ${daysUntilDue === 1 ? 'Due Tomorrow!' : `Due in ${daysUntilDue} days`}
        </p>
      </div>
      <p style="color: #374151; font-size: 16px; margin: 0 0 20px;">
        You have pending access review items for <strong>${campaignName}</strong>. Please complete your reviews before the deadline.
      </p>
      <a href="${dashboardUrl}" style="display: inline-block; background: ${urgencyColor}; color: white; text-decoration: none; padding: 12px 24px; border-radius: 6px; font-weight: 500;">
        Complete Reviews Now
      </a>
    </div>
    <div style="background: #f9fafb; padding: 15px; text-align: center; color: #6b7280; font-size: 12px;">
      Generated by AuditSphere
    </div>
  </div>
</body>
</html>`;
}

function generateAutoExecuteEmailHtml(
  campaignName: string,
  executedCount: number,
  errorCount: number,
  campaignId: string
): string {
  const dashboardUrl = `${APP_BASE_URL}/access-review/campaigns/${campaignId}`;
  const hasErrors = errorCount > 0;

  return `
<!DOCTYPE html>
<html>
<head><meta charset="utf-8"></head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f3f4f6; margin: 0; padding: 20px;">
  <div style="max-width: 600px; margin: 0 auto; background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <div style="background: ${hasErrors ? '#f59e0b' : '#10b981'}; padding: 30px; text-align: center;">
      <h1 style="color: white; margin: 0; font-size: 24px;">
        ${hasErrors ? '⚠️ Auto-Execute Completed with Errors' : '✅ Auto-Execute Completed'}
      </h1>
    </div>
    <div style="padding: 30px;">
      <p style="color: #374151; font-size: 16px; margin: 0 0 20px;">
        Access review campaign <strong>${campaignName}</strong> was past due and has been auto-executed.
      </p>
      <div style="display: flex; gap: 12px; margin-bottom: 20px;">
        <div style="flex: 1; background: #dcfce7; border-radius: 8px; padding: 15px; text-align: center;">
          <div style="font-size: 28px; font-weight: 700; color: #166534;">${executedCount}</div>
          <div style="font-size: 12px; color: #166534;">Executed</div>
        </div>
        ${hasErrors ? `
        <div style="flex: 1; background: #fee2e2; border-radius: 8px; padding: 15px; text-align: center;">
          <div style="font-size: 28px; font-weight: 700; color: #991b1b;">${errorCount}</div>
          <div style="font-size: 12px; color: #991b1b;">Failed</div>
        </div>
        ` : ''}
      </div>
      ${hasErrors ? `
      <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 0 8px 8px 0; margin-bottom: 20px;">
        <p style="margin: 0; color: #92400e; font-size: 14px;">
          Some removals failed. Please review the campaign for details.
        </p>
      </div>
      ` : ''}
      <a href="${dashboardUrl}" style="display: inline-block; background: #3b82f6; color: white; text-decoration: none; padding: 12px 24px; border-radius: 6px; font-weight: 500;">
        View Campaign Details
      </a>
    </div>
    <div style="background: #f9fafb; padding: 15px; text-align: center; color: #6b7280; font-size: 12px;">
      Generated by AuditSphere
    </div>
  </div>
</body>
</html>`;
}

// ============================================================================
// Campaign Auto-Start
// ============================================================================

interface CampaignScope {
  sites?: Array<{ siteId: string; siteName: string }>;
  siteUrls?: string[];
  includeDrives?: boolean;
  includeSubfolders?: boolean;
  maxDepth?: number;
}

/**
 * Auto-start a campaign: collect permissions from SharePoint
 */
async function autoStartCampaign(
  campaignId: string,
  userId: string,
  adminEmails: string[]
): Promise<void> {
  const campaign = await db.accessReviewCampaign.findUnique({
    where: { id: campaignId },
  });

  if (!campaign) return;

  // Get user's Microsoft connection
  const user = await db.user.findUnique({
    where: { id: userId },
    include: {
      microsoftConnections: {
        where: { status: 'active' },
        take: 1,
      },
    },
  });

  if (!user?.microsoftConnections.length) {
    console.error(`[AccessReview Scheduler] No Microsoft connection for user ${userId}, cannot auto-start campaign`);
    return;
  }

  // Update status to collecting
  await db.accessReviewCampaign.update({
    where: { id: campaignId },
    data: { status: 'collecting' },
  });

  try {
    const permissionsClient = new PermissionsClient(userId);
    const scope = campaign.scope as unknown as CampaignScope;

    // Handle both formats: sites array (with siteId) or siteUrls array (URLs to resolve)
    let siteIds: Array<{ siteId: string; siteName: string }> = [];

    if (scope.sites?.length) {
      siteIds = scope.sites;
    } else if (scope.siteUrls?.length) {
      // Resolve URLs to site IDs
      for (const url of scope.siteUrls) {
        try {
          const siteInfo = await permissionsClient.getSiteByUrl(url);
          if (siteInfo) {
            siteIds.push({ siteId: siteInfo.id, siteName: siteInfo.displayName || url });
          }
        } catch (err) {
          console.error(`[AccessReview Scheduler] Failed to resolve site URL ${url}:`, err);
        }
      }
    }

    const allPermissions: ResourcePermission[] = [];

    for (const site of siteIds) {
      // Collect site-level permissions
      try {
        const sitePermissions = await permissionsClient.collectSitePermissions(site.siteId);
        allPermissions.push(...sitePermissions);
      } catch (err) {
        console.error(`[AccessReview Scheduler] Error collecting site ${site.siteName}:`, err);
      }

      // If includeSubfolders is enabled, collect folder/file level permissions
      if (scope.includeDrives && scope.includeSubfolders) {
        try {
          const drives = await permissionsClient.getSiteDrives(site.siteId);
          for (const drive of drives) {
            try {
              const itemPermissions = await permissionsClient.findItemsWithUniquePermissions(
                site.siteId,
                drive.id,
                scope.maxDepth || 2
              );
              allPermissions.push(...itemPermissions);
              console.log(`[AccessReview Scheduler] Collected ${itemPermissions.length} folder/file permissions from drive "${drive.name}"`);
            } catch (err) {
              console.error(`[AccessReview Scheduler] Error collecting permissions for drive ${drive.name}:`, err);
            }
          }
        } catch (err) {
          console.error(`[AccessReview Scheduler] Error getting drives for site ${site.siteName}:`, err);
        }
      }
    }

    // Create review items for each permission
    let totalItems = 0;
    for (const perm of allPermissions) {
      try {
        await db.accessReviewItem.create({
          data: {
            campaignId,
            resourceType: perm.resourceType,
            resourceId: perm.resourceId,
            resourceName: perm.resourceName,
            resourcePath: perm.resourcePath,
            siteUrl: perm.siteUrl,
            permissionId: perm.permission.permissionId,
            permissionType: perm.permission.permissionType,
            grantedTo: perm.permission.grantedTo,
            grantedToId: perm.permission.grantedToId,
            grantedToType: perm.permission.grantedToType,
            accessLevel: perm.permission.accessLevel,
            permissionOrigin: perm.permission.permissionOrigin,
            sharingLinkType: perm.permission.sharingLinkType,
            expiresAt: perm.permission.expiresAt,
            // Assign to admin by default
            assignedReviewerEmail: adminEmails[0] || user.email,
          },
        });
        totalItems++;
      } catch (err) {
        // Skip duplicates (unique constraint violation)
        if (!(err instanceof Error && err.message.includes('Unique constraint'))) {
          console.error('[AccessReview Scheduler] Error creating item:', err);
        }
      }
    }

    // Update to in_review status
    await db.accessReviewCampaign.update({
      where: { id: campaignId },
      data: {
        status: 'in_review',
        totalItems,
        startDate: new Date(),
      },
    });

    console.log(`[AccessReview Scheduler] Auto-started campaign ${campaignId}: collected ${totalItems} items from ${siteIds.length} sites`);

    // Send notification to admins
    const emailClient = new EmailClient(userId);
    for (const adminEmail of adminEmails) {
      try {
        const htmlBody = generateCampaignStartedEmailHtml(campaign.name, totalItems, campaignId);
        await emailClient.sendEmail(user.email, {
          to: [adminEmail],
          subject: `Access Review Started: ${campaign.name}`,
          body: htmlBody,
          bodyType: 'html',
        });
      } catch (err) {
        console.error(`[AccessReview Scheduler] Failed to send start email to ${adminEmail}:`, err);
      }
    }

    // Create in-app notification
    await db.accessReviewNotification.create({
      data: {
        userId,
        campaignId,
        type: 'campaign_started',
        title: 'Access Review Started',
        message: `Campaign "${campaign.name}" has been automatically started with ${totalItems} items to review.`,
        sentAt: new Date(),
      },
    });
  } catch (error) {
    console.error(`[AccessReview Scheduler] Failed to auto-start campaign ${campaignId}:`, error);
    // Revert to draft on failure
    await db.accessReviewCampaign.update({
      where: { id: campaignId },
      data: { status: 'draft' },
    });
  }
}

// ============================================================================
// Schedule Processing
// ============================================================================

/**
 * Check for due scheduled reviews and create campaigns
 */
async function checkDueSchedules(): Promise<void> {
  const now = new Date();

  // Find enabled schedules that are due
  const dueSchedules = await db.scheduledReview.findMany({
    where: {
      enabled: true,
      nextRunAt: {
        lte: now,
      },
    },
    include: {
      createdBy: true,
    },
  });

  for (const schedule of dueSchedules) {
    try {
      console.log(`[AccessReview Scheduler] Running schedule: ${schedule.name}`);

      // Calculate due date based on review period
      const dueDate = new Date();
      dueDate.setDate(dueDate.getDate() + schedule.reviewPeriodDays);

      // Create a new campaign from the schedule
      const campaign = await db.accessReviewCampaign.create({
        data: {
          name: `${schedule.name} - ${now.toLocaleDateString()}`,
          description: schedule.description || `Auto-generated from schedule: ${schedule.name}`,
          scope: schedule.scope as Prisma.InputJsonValue,
          status: 'draft',
          dueDate,
          timezone: schedule.timezone,
          reminderDays: schedule.reminderDays[0] || 3,
          notifyAdminsOnComplete: schedule.notifyAdmins,
          adminEmails: schedule.adminEmails,
          createdById: schedule.createdById,
          scheduledReviewId: schedule.id,
        },
      });

      // Calculate next run date
      const nextRunAt = calculateNextRun(
        schedule.frequency,
        schedule.dayOfWeek ?? undefined,
        schedule.dayOfMonth ?? undefined,
        schedule.monthOfYear ?? undefined,
        schedule.time,
        schedule.timezone
      );

      // Update schedule
      await db.scheduledReview.update({
        where: { id: schedule.id },
        data: {
          lastRunAt: now,
          nextRunAt,
          lastCampaignId: campaign.id,
        },
      });

      console.log(`[AccessReview Scheduler] Created campaign: ${campaign.id}`);

      // Auto-start the campaign: collect permissions from configured scope
      await autoStartCampaign(campaign.id, schedule.createdById, schedule.adminEmails);
    } catch (error) {
      console.error(`[AccessReview Scheduler] Error running schedule ${schedule.id}:`, error);
    }
  }
}

// ============================================================================
// Reminder Processing
// ============================================================================

/**
 * Check for campaigns due soon and send reminders
 */
async function checkReminders(): Promise<void> {
  const now = new Date();

  // Find campaigns in review with upcoming due dates
  const campaigns = await db.accessReviewCampaign.findMany({
    where: {
      status: 'in_review',
      dueDate: {
        gt: now,
      },
    },
    include: {
      createdBy: {
        include: {
          microsoftConnections: {
            where: { status: 'active' },
            take: 1,
          },
        },
      },
    },
  });

  for (const campaign of campaigns) {
    if (!campaign.dueDate) continue;

    const daysUntilDue = Math.ceil(
      (campaign.dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
    );

    // Check if we should send a reminder (at 7, 3, 1 days before)
    const reminderDays = [7, 3, 1];
    if (!reminderDays.includes(daysUntilDue)) continue;

    // Get reviewers with pending items
    const pendingItems = await db.accessReviewItem.findMany({
      where: {
        campaignId: campaign.id,
        OR: [
          { decision: null },
          { decision: { decision: 'pending' } },
        ],
      },
      select: {
        assignedReviewerEmail: true,
      },
      distinct: ['assignedReviewerEmail'],
    });

    // Get email client if user has Microsoft connection
    let emailClient: EmailClient | null = null;
    let senderEmail: string | null = null;
    if (campaign.createdBy?.microsoftConnections.length) {
      emailClient = new EmailClient(campaign.createdById);
      senderEmail = campaign.createdBy.email;
    }

    for (const item of pendingItems) {
      if (!item.assignedReviewerEmail) continue;

      // Check if we already sent a reminder today
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const existingReminder = await db.accessReviewNotification.findFirst({
        where: {
          campaignId: campaign.id,
          type: 'campaign_due_soon',
          createdAt: {
            gte: todayStart,
          },
        },
      });

      if (existingReminder) continue;

      const subject = `⏰ Reminder: Access Review "${campaign.name}" Due in ${daysUntilDue} day(s)`;
      const body = `You have pending access reviews for "${campaign.name}". Please complete your reviews before the due date.`;

      // Send actual email if we have email client
      let sentAt: Date | null = null;
      if (emailClient && senderEmail) {
        try {
          const htmlBody = generateReminderEmailHtml(campaign.name, daysUntilDue, campaign.id);
          const result = await emailClient.sendEmail(senderEmail, {
            to: [item.assignedReviewerEmail],
            subject,
            body: htmlBody,
            bodyType: 'html',
          });
          if (result.success) sentAt = new Date();
        } catch (err) {
          console.error(`[AccessReview Scheduler] Failed to send reminder to ${item.assignedReviewerEmail}:`, err);
        }
      }

      // Create in-app notification
      await db.accessReviewNotification.create({
        data: {
          userId: campaign.createdById,
          campaignId: campaign.id,
          type: 'campaign_due_soon',
          title: `Review Due in ${daysUntilDue} Day${daysUntilDue > 1 ? 's' : ''}`,
          message: body,
          sentAt,
        },
      });
    }
  }
}

// ============================================================================
// Auto-Execute Processing
// ============================================================================

/**
 * Check for overdue campaigns and handle auto-execution of removals
 */
async function checkOverdueCampaigns(): Promise<void> {
  const now = new Date();

  // Find scheduled reviews with autoExecute enabled
  const autoExecuteSchedules = await db.scheduledReview.findMany({
    where: {
      autoExecute: true,
      lastCampaignId: { not: null },
    },
  });

  const campaignIds = autoExecuteSchedules
    .map(s => s.lastCampaignId)
    .filter((id): id is string => id !== null);

  // Find campaigns that are past due and have pending removals
  const pastDueCampaigns = await db.accessReviewCampaign.findMany({
    where: {
      id: { in: campaignIds },
      status: 'in_review',
      dueDate: { lt: now },
    },
    include: {
      createdBy: {
        include: {
          microsoftConnections: {
            where: { status: 'active' },
            take: 1,
          },
        },
      },
    },
  });

  for (const campaign of pastDueCampaigns) {
    // Send overdue notification if not already sent
    const existingOverdueNotification = await db.accessReviewNotification.findFirst({
      where: {
        campaignId: campaign.id,
        type: 'campaign_overdue',
      },
    });

    if (!existingOverdueNotification) {
      const pendingCount = await db.accessReviewItem.count({
        where: { campaignId: campaign.id, decision: null },
      });

      await db.accessReviewNotification.create({
        data: {
          userId: campaign.createdById,
          campaignId: campaign.id,
          type: 'campaign_overdue',
          title: 'Access Review Overdue',
          message: `Access review campaign "${campaign.name}" is overdue. ${pendingCount} items still need review.`,
        },
      });
    }

    // Check if user has Microsoft connection for execution
    if (!campaign.createdBy?.microsoftConnections.length) {
      console.log(`[AccessReview Scheduler] Campaign ${campaign.id}: No Microsoft connection for auto-execute`);
      continue;
    }

    // Get pending removal items
    const pendingRemovalItems = await db.accessReviewItem.findMany({
      where: {
        campaignId: campaign.id,
        decision: {
          decision: 'remove',
          executionStatus: 'pending',
        },
      },
      include: {
        decision: true,
      },
    });

    if (pendingRemovalItems.length === 0) {
      // No pending removals - check if campaign should complete
      await checkCampaignCompletion(campaign.id, campaign.createdById, campaign.name);
      continue;
    }

    console.log(`[AccessReview Scheduler] Auto-executing ${pendingRemovalItems.length} removals for campaign ${campaign.id}`);

    const permissionsClient = new PermissionsClient(campaign.createdById);
    let executedCount = 0;
    let errorCount = 0;

    for (const item of pendingRemovalItems) {
      if (!item.decision) continue;

      try {
        // Update status to in_progress
        await db.accessReviewDecision.update({
          where: { id: item.decision.id },
          data: { executionStatus: 'in_progress' },
        });

        // Execute the removal based on resource type
        if (item.resourceType === 'site') {
          await permissionsClient.deleteSitePermission(item.resourceId, item.permissionId);
        } else {
          // For drive items, resourceId format is "driveId:itemId"
          if (item.resourceId.includes(':')) {
            const [driveId, itemId] = item.resourceId.split(':');
            await permissionsClient.deleteDriveItemPermission(driveId, itemId, item.permissionId);
          } else {
            throw new Error(`Invalid resource ID format: ${item.resourceId}`);
          }
        }

        // Update decision status
        await db.accessReviewDecision.update({
          where: { id: item.decision.id },
          data: {
            executionStatus: 'completed',
            executedAt: new Date(),
          },
        });
        executedCount++;
      } catch (error) {
        console.error(`[AccessReview Scheduler] Failed to auto-execute removal for item ${item.id}:`, error);
        await db.accessReviewDecision.update({
          where: { id: item.decision.id },
          data: {
            executionStatus: 'failed',
            executionError: error instanceof Error ? error.message : 'Unknown error',
          },
        });
        errorCount++;
      }
    }

    // Update campaign stats
    const removedItems = await db.accessReviewDecision.count({
      where: {
        item: { campaignId: campaign.id },
        decision: 'remove',
        executionStatus: 'completed',
      },
    });

    await db.accessReviewCampaign.update({
      where: { id: campaign.id },
      data: { removedItems },
    });

    // Check if campaign should complete
    await checkCampaignCompletion(campaign.id, campaign.createdById, campaign.name);

    // Send notification to admins
    const emailClient = new EmailClient(campaign.createdById);
    for (const adminEmail of campaign.adminEmails) {
      try {
        const htmlBody = generateAutoExecuteEmailHtml(campaign.name, executedCount, errorCount, campaign.id);
        await emailClient.sendEmail(campaign.createdBy.email, {
          to: [adminEmail],
          subject: `${errorCount > 0 ? '⚠️' : '✅'} Auto-Execute ${errorCount > 0 ? 'Completed with Errors' : 'Completed'}: ${campaign.name}`,
          body: htmlBody,
          bodyType: 'html',
        });
      } catch (err) {
        console.error(`[AccessReview Scheduler] Failed to send auto-execute email to ${adminEmail}:`, err);
      }
    }

    console.log(`[AccessReview Scheduler] Auto-executed campaign ${campaign.id}: ${executedCount} succeeded, ${errorCount} failed`);
  }
}

/**
 * Check if campaign should be marked as completed
 */
async function checkCampaignCompletion(
  campaignId: string,
  userId: string,
  campaignName: string
): Promise<void> {
  const [itemsWithoutDecision, pendingRemovals] = await Promise.all([
    db.accessReviewItem.count({
      where: { campaignId, decision: null },
    }),
    db.accessReviewDecision.count({
      where: {
        item: { campaignId },
        decision: 'remove',
        executionStatus: 'pending',
      },
    }),
  ]);

  if (itemsWithoutDecision === 0 && pendingRemovals === 0) {
    const [retainCount, removeCount] = await Promise.all([
      db.accessReviewDecision.count({
        where: { item: { campaignId }, decision: 'retain' },
      }),
      db.accessReviewDecision.count({
        where: { item: { campaignId }, decision: 'remove', executionStatus: 'completed' },
      }),
    ]);

    await db.accessReviewCampaign.update({
      where: { id: campaignId },
      data: {
        status: 'completed',
        completedAt: new Date(),
        reviewedItems: retainCount + removeCount,
        retainedItems: retainCount,
        removedItems: removeCount,
      },
    });

    // Create completion notification
    await db.accessReviewNotification.create({
      data: {
        userId,
        campaignId,
        type: 'execution_complete',
        title: 'Access Review Completed',
        message: `Access review campaign "${campaignName}" has been completed. ${retainCount} permissions retained, ${removeCount} permissions removed.`,
      },
    });
  }
}

// ============================================================================
// Schedule Calculation
// ============================================================================

/**
 * Calculate next run date for a schedule with timezone support
 */
function calculateNextRun(
  frequency: string,
  dayOfWeek?: number,
  dayOfMonth?: number,
  monthOfYear?: number,
  time: string = '09:00',
  timezone: string = 'UTC'
): Date {
  const now = new Date();
  const [hours, minutes] = time.split(':').map(Number);

  // Create date in specified timezone
  let next = new Date(now);
  next.setHours(hours, minutes, 0, 0);

  // Start from tomorrow to avoid running twice on the same day
  if (next <= now) {
    next.setDate(next.getDate() + 1);
  }

  switch (frequency) {
    case 'weekly': {
      const targetDay = dayOfWeek ?? 1; // Default to Monday
      const currentDay = next.getDay();
      let daysUntil = targetDay - currentDay;
      if (daysUntil <= 0) {
        daysUntil += 7;
      }
      next.setDate(next.getDate() + daysUntil);
      break;
    }

    case 'monthly': {
      const targetDate = dayOfMonth ?? 1;
      next.setDate(targetDate);
      if (next <= now) {
        next.setMonth(next.getMonth() + 1);
      }
      // Handle months with fewer days
      while (next.getDate() !== targetDate) {
        next.setDate(0); // Go to last day of previous month
        next.setMonth(next.getMonth() + 1);
        next.setDate(Math.min(targetDate, new Date(next.getFullYear(), next.getMonth() + 1, 0).getDate()));
      }
      break;
    }

    case 'quarterly': {
      const quarterMonths = [0, 3, 6, 9]; // Jan, Apr, Jul, Oct
      const currentMonth = now.getMonth();
      let nextQuarterMonth = quarterMonths.find(m => m > currentMonth);
      if (nextQuarterMonth === undefined) {
        nextQuarterMonth = quarterMonths[0];
        next.setFullYear(next.getFullYear() + 1);
      }
      next.setMonth(nextQuarterMonth);
      next.setDate(dayOfMonth ?? 1);
      if (next <= now) {
        // Move to next quarter
        const idx = quarterMonths.indexOf(nextQuarterMonth);
        if (idx < quarterMonths.length - 1) {
          next.setMonth(quarterMonths[idx + 1]);
        } else {
          next.setFullYear(next.getFullYear() + 1);
          next.setMonth(quarterMonths[0]);
        }
      }
      break;
    }

    case 'yearly': {
      const targetMonth = (monthOfYear ?? 1) - 1; // Convert 1-12 to 0-11
      next.setMonth(targetMonth);
      next.setDate(dayOfMonth ?? 1);
      if (next <= now) {
        next.setFullYear(next.getFullYear() + 1);
      }
      break;
    }
  }

  return next;
}

// ============================================================================
// Scheduler Main Loop
// ============================================================================

/**
 * Main scheduler loop
 */
async function runScheduler(): Promise<void> {
  if (isRunning) {
    console.log('[AccessReview Scheduler] Already running, skipping...');
    return;
  }

  isRunning = true;
  console.log('[AccessReview Scheduler] Running checks...');

  try {
    await checkDueSchedules();
    await checkReminders();
    await checkOverdueCampaigns();
  } catch (error) {
    console.error('[AccessReview Scheduler] Error:', error);
  } finally {
    isRunning = false;
  }
}

/**
 * Start the scheduler
 */
export function startAccessReviewScheduler(): void {
  console.log('[AccessReview Scheduler] Starting...');

  // Run immediately
  void runScheduler();

  // Then run on interval
  intervalId = setInterval(() => {
    void runScheduler();
  }, CHECK_INTERVAL);
}

/**
 * Stop the scheduler
 */
export function stopAccessReviewScheduler(): void {
  if (intervalId) {
    clearInterval(intervalId);
    intervalId = null;
    console.log('[AccessReview Scheduler] Stopped');
  }
}

export { runScheduler, checkDueSchedules, checkReminders, checkOverdueCampaigns, calculateNextRun };
